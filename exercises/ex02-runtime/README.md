# Runtime

A Substrate based blockchain is made of the sum of the pallets it includes.
In this exercise, you are going to learn how to include a pallet in a runtime.

We added a git submodule to this repository: [substrate-node-template](https://github.com/substrate-developer-hub/substrate-node-template).  
It's a great unlicenced project that offers a functional, yet empty, Substrate blockchain. You can think about it as a skeleton, ready to receive the flesh and life you chose to infuse in it.
We are going to add the asset pallet we wrote in the previous exercise to this runtime, and then run it.

## Step 0: Dry run

```shell
$ cd substrate-node-template
$ cargo build
$ cargo run -- --dev
```
Your terminal should fill with logs looking like this:
```shell
2022-06-07 20:05:48 üôå Starting consensus session on top of parent 0x7473cd45e528ceaac265e04a9bc5551e6c16470f3f95cf56a8d375b7a32751db    
2022-06-07 20:05:48 üéÅ Prepared block for proposing at 1 (27 ms) [hash: 0x2a87af7f2257a0942384849e2895c5fa5441288af1314b73955a2e3e9e2f4c88; parent_hash: 0x7473‚Ä¶51db; extrinsics (1): [0x11eb‚Ä¶c073]]    
2022-06-07 20:05:48 üîñ Pre-sealed block for proposal at 1. Hash now 0x63d92c4a748d728978c483b92cf8c26084f22b54069dd3878e36ca8484ab373a, previously 0x2a87af7f2257a0942384849e2895c5fa5441288af1314b73955a2e3e9e2f4c88.    
2022-06-07 20:05:48 ‚ú® Imported #1 (0x63d9‚Ä¶373a)    
2022-06-07 20:05:49 üí§ Idle (0 peers), best: #1 (0x63d9‚Ä¶373a), finalized #0 (0x7473‚Ä¶51db), ‚¨á 0 ‚¨Ü 0   
```
It means that the chain is running and producing new blocks. Good.

Now open the `Polkadot.js` app, either in your [web navigator](https://polkadot.js.org/apps/#/explorer) or on [desktop](https://github.com/polkadot-js/apps/releases).
Connect to your local development chain (top left icon, `DEVELOPMENT` section, `Local Node`, hit the top `Switch` button with two arrows forming a circle), by default at `127.0.0.1:9944`.
Bravo! You can now interact with the chain that is running on your local machine.
Take some time to explore the UI, you can go to the Developer/Extrinsic section and do some calls, even transfer some funds using the pallet Balances.

Great. Now go back to your terminal and hit `Ctrl + c` to kill the chain. We are going to add our own stuff now.

## Step 1: Import our code

To be able to use our code in this project, we have to add it to the manifest.  
Open `substrate-node-template/runtime/Cargo.toml`.
And add `pallet_assets` as a dependecy:
```toml
[dependencies]
...
# Local Dependencies
pallet-template = { version = "4.0.0-dev", default-features = false, path = "../pallets/template" }
pallet-assets   = { path = "../../exercises/ex01-fungible-token/assets", default-features = false }
```

Compile again to make sure the crate is well added to the project.


## Step 1: construct_runtime!

Open `substrate-node-template/runtime/src/lib.rs`.  
Find the `construct_runtime!` macro call. That's where we declare the pallets we want our runtime to use. That's where we have to add our `assets` pallet.

First thing first, add the pallet assets to the runtime.
```rust
construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
        ...
		Assets: pallet_assets,
	}
);
```

Now try a `cargo build`... it fails miserably. Why? Because we declared our intention to use the pallet `assets` in the runtime but we did not give it any configuration. What does it mean?  
Remember this part of `exercises/ex01-fungible-token/assets/src/lib.rs`?

```rust
	#[pallet::config]
	pub trait Config: frame_system::Config {
		/// Because this pallet emits events, it depends on the runtime's definition of an event.
		type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;

		#[pallet::constant]
		type MaxLength: Get<u32>;
	}
```
It states that to run, this pallet must be provided with an `Event` type (to emit runtime events), and a `MaxLength` type (used to store strings as `BoundedVec`).  
So let's give those types to the runtime.

Just over the `construct_runtime!` macro add these lines:

```rust
impl pallet_assets::Config for Runtime {
    ...
}
```

So `Runtime` is a type, generated by `construct_runtime` and we are going to implement the `pallet_assets::Config` trait on it.  
The `Event` type is easy to add, just look up and copy what has been done for the other pallets, but the `MaxLength` is more tricky.
Try to give it a value, let's say we want our string to be at most `20` characters long:
```rust
	type MaxLength = 20;
```
Run `cargo check`, it fails and explains that a type is expected instead. But how do we create such a type?  
We use the `parameter_types!` macro:

```rust
parameter_types! {
	pub const MaxStringLength: u32 = 20;
}


impl pallet_assets::Config for Runtime {
	type Event = Event;
	type MaxLength = MaxStringLength;
}
```

And that's it, you can now build and run your chain again, and make calls to the extrinsics of the `assets` pallet you created.  
Create an asset, set its metadata, mint some, transfer and burn part of it.
